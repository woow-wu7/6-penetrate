<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 题目
      // 3. 无重复字符的最长子串

      // 思路
      // - 一般遇到 ( 子串问题 )，可以考虑使用 ( 滑动窗口 - 双指针 ) 的思想

      // 本题思路
      // 1. 基本组成: 左右两个指针，一个set，两个变量 len maxLen
      // 2. 移动右指针
      //      - 右指针的值在set中不存在 - 添加 进set
      //      - 右指针的值在set中存在 - 删除左指针的值，然后移动左指针，再判断右指针的值在set中否存在
      //          - 不存在 - 就将右指针的值添加进set，并移动右指针
      //          - 存在 - 继续删除左指针的值，并移动左指针

      /**
       * @param {string} s
       * @return {number}
       */

      const s = "abcabcbb"; // 3
      // const s = "bbbbb"; // 1
      // s = "pwwkew"; // 3

      var lengthOfLongestSubstring = function (s) {
        let left = (right = len = maxLen = 0);
        let set = new Set();

        // 总的条件: 右指针遍历完就结束整个遍历
        while (right < s.length) {
          // 1. 右指针的值 在 set 不存在
          // ------------------------------------------ 这段代码和 YYY 是重复的，可以做优化，这里为了方便理解不做优化了
          if (!set.has(s[right])) {
            set.add(s[right]);
            len++;
            if (maxLen < len) maxLen = len;
            right++;
          }
          // 2. 右指针的值 在 set 不存在，就移动左指针，直到 right指针的值在set中不存在为止
          else {
            // 右指针的值在set中存在
            while (set.has(s[right])) {
              set.delete(s[left]); // 删除左指针 在 set 中的值
              left++;
              len--;
            }
            //  --------------------------------------- YYY
            set.add(s[right]); // 左指针不能在移动时，将 右指针 的值添加到 set 中
            len++;
            if (maxLen < len) maxLen = len;
            right++; // 右移 右指针
          }
        }

        return maxLen;
      };
    </script>

    <script>
      // 暴力求解
      /**
       * @param {string} s
       * @return {number}
       */
      // const s = "abcabcbb"; // 3
      // const s = "bbbbb"; // 1
      // s = "pwwkew"; // 3

      /**
        var lengthOfLongestSubstring = function (s) {
        let res = "";
        const len = s.length;

        if (!len) return 0;

        const allSame = s.split("").reduce((prev, current) => {
          return prev === current;
        });
        if (allSame) return 1;

        for (let i = 0; i < len; i++) {
          for (let j = i + 1; j <= len; j++) {
            const str = s.slice(i, j).split("").sort().join("");
            let hasSame = false;
            for (let k = 0; k < str.length; k++) {
              if (str[k] === str[k + 1]) {
                hasSame = true;
              }
            }
            if (!hasSame) {
              if (res.length < str.length) {
                res = str;
              }
            }
          }
        }
        return res.length;
      };
      const res = lengthOfLongestSubstring(s);
      console.log("res: ", res);
    ***/
    </script>
  </body>
</html>
