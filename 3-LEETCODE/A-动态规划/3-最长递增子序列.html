<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 300. 最长递增子序列

      // 1
      // 题目
      // 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
      // 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

      // 2
      // 链接 https://leetcode.cn/problems/longest-increasing-subsequence/

      /**
       * @param {number[]} nums
       * @return {number}
       */

      var lengthOfLIS = function (nums) {
        // dp
        // dp[i]: 表示 nums数组中以 i 结尾的 最长递增子序列的长度
        // fill(1): 是因为每个位置的初始长度是 1
        const dp = new Array(nums.length).fill(1);

        // max: 表示最终返回的 最长递增子序列的长度
        let max = 1;

        for (let i = 0; i < nums.length; i++) {
          for (let j = 0; j < i; j++) {
            // j < i 表示的是 i 位置之前的所有位置的 最长递增子序列
            // 遍历，找到 ( 每个位置最长递增子序列长度的较大值 + 1 = 当前位置的最长递增子序列长度 )
            if (nums[j] < nums[i]) {
              // 是递增，所以取小于的
              dp[i] = Math.max(dp[j] + 1, dp[i]);
            }
          }

          // max
          // 从每个位置最长递增子序列长度中，找到最大的，作为最终的返回值
          // 我们这里是动态更新的而已
          max = Math.max(dp[i], max);
        }

        return max;
      };
    </script>
  </body>
</html>
