<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 广度优先遍历 BFS - Breadth First Search
      // 102. 二叉树的层序遍历 - 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
      /**
       * Definition for a binary tree node.
       * function TreeNode(val, left, right) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.left = (left===undefined ? null : left)
       *     this.right = (right===undefined ? null : right)
       * }
       */
      /**
       * @param {TreeNode} root
       * @return {number[][]}
       */
      const root = {
        val: 1,
        left: {
          val: 2,
          left: {
            val: 3,
          },
          right: {
            val: 4,
          },
        },
        right: {
          val: 5,
          left: {
            val: 6,
          },
          right: {
            val: 7,
          },
        },
      };

      var levelOrder = function (root) {
        const result = []; // 最终结果
        const queue = [root]; // 队列，先进先出，对应 push 和 shift 方法

        const recursive = () => {
          // 队列中有成员就从前往后弹出，先进先出
          // - 1. 当2出队时，入队35，则队列中有 [5, 3, 4]
          // - 2. 下次递归，就是 5 出队，入队67， 则队列中有 [3,4,6,7]
          // - 3. 正好是广度优先遍历
          if (queue.length) {
            const target = queue.shift(); // 左边出队
            if (target) {
              result.push(target.val);
              if (target.left) queue.push(target.left); // 左边先入队
              if (target.right) queue.push(target.right);
              recursive();
            }
          }
        };

        recursive();

        return result;
      };
      const res = levelOrder(root);
      console.log("res: ", res);
    </script>
  </body>
</html>
