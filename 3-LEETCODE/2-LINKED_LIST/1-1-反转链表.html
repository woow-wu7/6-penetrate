<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 反转链表

      // 1
      // 扩展
      // 链表 和 数组 的区别？
      // - 查找
      //   - 数组: 数组的 ( 内存空间 ) 是 ( 连续 ) 的，可以通过 ( 计算偏移量 ) 来寻找，( 效率高 )
      //   - 链表: 链表的 ( 内存空间 ) 是 ( 不连续 )，链表是通过 ( 地址指针 ) 来寻找目标节点，每次都需要从头遍历，( 效率低 )
      // - 添加 和 删除
      //   - 数组: 数组的 ( 添加和删除 ) 元素后，( 由于要填充之前的位置，需要移动很多元素 )，所以 ( 数组的添加和删除 - 效率低 )
      //   - 链表: 链表的 ( 添加和删除 ) 只需要求改指针的指向，是不需要移动内存空间的内容的，所以 ( 链表的添加删除的 - 效率高 )
      // - 总结
      //   - 数组查找效率高，链表添加和删除效率高

      // 2
      // 题目
      // 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
      // ---
      // 输入： head = [1,2,3,4,5]
      // 输出： [5,4,3,2,1]
      // ---
      // 输入：head = []
      // 输出：[]
      // ---

      /**
       * Definition for singly-linked list.
       * function ListNode(val, next) {
       *     this.val = (val===undefined ? 0 : val)
       *     this.next = (next===undefined ? null : next)
       * }
       */
      /**
       * @param {ListNode} head
       * @return {ListNode}
       */
      var reverseList = function (head) {
        // if (!head) return null;
        // if (!head.next) return head;
        if (!head || !head.next) return head; // 边界，等价于上面两句代码

        let [pre, cur] = [null, head];
        // 声明两个变量
        // pre 用来标记正序链表的头节点
        // cur 当前正序的正在处理的节点

        // 如果当前节点存在
        while (cur) {
          const temp = cur.next; // 用来缓存当前正序的下一个节点，因为之后会去修改cur，就不知道下一个节点是指向谁了，所以先缓存起来

          cur.next = pre; // 反转链表，指向反转链表的头节点 ( 即将当前节点的指针指向上一个节点 )

          // 以下是反转链表后的处理，即 ( 往后移动指针 )，进行下一次遍历
          pre = cur; // 反转链表的头节点就是cur，当前的pre就是上一次的cur
          cur = temp; // 正序的链表指针向后移，进行下一轮处理
        }

        return pre; // 返回反转后的链表头节点，注意不是cur，此时的cur是null，应该是前一个节点
      };
    </script>
  </body>
</html>
