<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 总

      // (1)
      // promise
      // - 1. promise中错误的处理
      // - 2. 执行顺序
      //    - 1. then是异步任务
      //    - 2. then 和 resolve 执行顺序的处理
      // - 3. then 的穿透效果，两个回调参数的执行时机
      // - 4. resolve 和 reject 的三个作用
      // - 5. 魔法字符串的处理

      // (2)
      // Promise.all
      // 特点：
      //  1. 返回一个新的 promise 对象
      //  2. 参数是promise实例的数组，成员不是promise对象会用Promise.resolve()转成promise对象
      //  3. 所有fulfilled -> 整个fulfilled
      //  4. 一个rejected --> 整个rejected

      // (3)
      // Promise.race
      // 特点：
      //  1. 返回一个新的 promise 对象
      //  2. 参数是promise实例的数组，成员不是promise对象会用Promise.resolve()转成promise对象
      //  3. 谁先fulfilled -> 整个fulfilled
      //  4. 谁先rejected --> 整个rejected
      // 实现:
      // - Promise.race 和 Promise.all 的实现类似

      class _Promise {
        constructor(executor) {
          // promise中的错误，需要被then的失败回调捕获
          try {
            executor(this.resolve, this.reject);
          } catch (err) {
            this.reject(err);
          }
        }

        status = _Promise.PENDING; // 初始状态 pending
        value = null;
        reason = null;
        onFulfilledCallbacks = []; // 收集 then 方法中的成功回调
        onRejectedCallbacks = [];

        // resolve
        // 有三个作用
        // - 1. 改变状态 pending -> fulfilled
        // - 2. 存储终值 value
        // - 3. flush调onFulfilledCallback中的函数，因为executor有异步时，then优先于resolve执行，而then的执行需要在状态改变后，所以then在pending时push，resolve执行时flush
        resolve = (value) => {
          this.value = value;
          this.status = _Promise.FULFILLED;
          if (this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.forEach((fn) => fn(this.value));
          }
        };
        reject = (reason) => {
          this.reason = reason;
          this.status = _Promise.REJECTED;
          if (this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.forEach((fn) => fn(this.reason));
          }
        };

        then = (onFulfilled, onRejected) => {
          // 3
          // then 具有穿透效果
          if (typeof onFulfilled !== "function") {
            onFulfilled = (value) => value;
          }
          if (typeof onRejected !== "function") {
            onRejected = (reason) => {
              throw new Error();
            };
          }

          if (this.status === _Promise.FULFILLED) {
            // 1
            // onFulfilled(this.value); // ------------------- 1234
            // 待解决问题：这里需要解决第一个问题：执行顺序1243，而不是1234
            // 原因：因为 then 的执行是要在所有同步任务执行完后，才会执行
            // 如何解决：使用 setTimeout 模拟异步来解决

            setTimeout(() => onFulfilled(this.value)); // ---- 1243
          }

          if (this.status === _Promise.REJECTED) {
            // onRejected(this.reason);
            setTimeout(() => onRejected(this.reason));
          }

          // 2
          // 待解决问题：当 executor 中有异步任务时，then成功的回调没有执行
          // 原因：因为 then 执行是在 ( 状态改变后 )，即 ( resolve 或 reject 执行后 ) 改变了状态后，才会执行 then，而当executor有异步时，resolve就会延时执行，then先于resolve执行，所以两个回调并没有执行
          // 如何解决：在 then 函数内部，当状态没改变时即还是pending时，将参数回调放入队列onFulfilledCallback，在resolve改变状态后取出来执行

          if (this.status === _Promise.PENDING) {
            // 这里不用再判断 onFulfilled 和 onRejected 不存在的情况了，上面已经判断了，必须为函数，不是函数会被转成相关函数
            this.onFulfilledCallbacks.push((value) => {
              setTimeout(() => onFulfilled(value));
            });

            this.onRejectedCallbacks.push((value) => {
              setTimeout(() => setTimeout((reason) => onRejected(this.reason)));
            });
          }
        };
      }

      // class 的静态属性，这里是为了避免魔法字符串的产生
      _Promise.PENDING = "pending";
      _Promise.FULFILLED = "fulfilled";
      _Promise.REJECTED = "rejected";

      // ------ promise 测试
      console.log(1);
      new _Promise((resolve, reject) => {
        console.log(2);
        setTimeout(() => {
          resolve(3);
        });
        // 4
        // promise中如果有错，需要被then的失败回调捕获
        // throw new Error("出错了");
      }).then(
        (res) => console.log(res),
        (reason) => console.log(reason)
      );
      console.log(4);
      // 1243

      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // Promise.all()
      _Promise.all = (promises) => {
        // Promise.all
        // 1. 是静态方法
        // 2. 返回一个新的 promise
        return new Promise((resolve, reject) => {
          // res
          // - 存储终值，即所有都是fulfilled状态下的终值数组
          const res = [];

          // promiseArr
          // - 把 promise 数组或类数组对象都转成数组，并把所有数组成员转成promise对象
          const promiseArr = Array.from(promises).map((p) =>
            Promise.resolve(p)
          );

          promiseArr.forEach((p) => {
            // promise对象可以接着 .then()
            // 这里给每个promise都使用 then 方法来收集终值
            p.then(
              // 成功的回调
              (value) => {
                res.push(value); // 搜集终值
                if (res.length === promiseArr.length) {
                  // 结束条件，终值收集满了，说明所有promise的状态都fulfilled了
                  resolve(res);
                }
              },
              // 失败的回调
              // - 一个 rejected，整个rejected
              // - 这里是一个简写形式，相等于 reason => reject(reason)
              reject
            );
          });
        });
      };

      // ------ Promise.all 测试
      const p1 = Promise.resolve(1);
      const p2 = new Promise((resolve) => setTimeout(() => resolve(2), 2000));
      const p3 = new Promise((resolve) => setTimeout(() => resolve(3), 3000));
      _Promise
        .all([p1, p2, p3])
        .then((resArr) => console.log("_Promise.all()测试 :>> ", resArr));

      Promise.all([p1, p2, p3]).then((resArr) =>
        console.log("Promise.all()测试 :>> ", resArr)
      );

      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // 分割线 ------------------------------------------------------------------------------------
      // Promise.race()
      // - race 是竞赛的意思
      _Promise.race = (promises) => {
        return new Promise((resolve, reject) => {
          const res = [];
          const promiseArr = Array.from(promises).map((p) =>
            Promise.resolve(p)
          );

          promiseArr.forEach((p) => {
            p.then(
              (value) => resolve(value),
              (reason) => reject(reason)
            );
          });
        });
      };
      _Promise
        .race([p1, p2, p3])
        .then((resArr) => console.log("_Promise.race()测试 :>> ", resArr));

      Promise.race([p1, p2, p3]).then((resArr) =>
        console.log("Promise.race()测试 :>> ", resArr)
      );
    </script>
  </body>
</html>
