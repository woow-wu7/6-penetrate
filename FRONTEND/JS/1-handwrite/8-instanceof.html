<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // instanceof
      // obj instanceof constructor
      // 原理: 右边构造函数的 prototype 属性是否在 左边对象的 原型链上

      const origin = { name: "woow_wu7" };
      const obj = Object.create(origin);
      console.log("obj instanceof Object :>> ", obj instanceof Object); // true

      const _instanceof = (obj, constructor) => {
        const rightPrototype = constructor.prototype;
        let leftPrototype = Object.getPrototypeOf(obj);

        while (true) {
          if (leftPrototype === null) return false; // 如果到了原型链的终点都不想等，则false
          if (leftPrototype === rightPrototype) return true;

          // false 的情况如下；不相等，继续往上寻找原型对象
          leftPrototype = Object.getPrototypeOf(leftPrototype);
        }
      };

      const arr = [1];
      const res = _instanceof(arr, Array);
      console.log("res", res);

      console.log(
        "Object.getPrototypeOf(arr) === Array.prototype :>> ",
        Object.getPrototypeOf(arr) === Array.prototype
      ); // true
      console.log("arr instanceof Array", arr instanceof Array); // true
    </script>

    <!-- 下面的写法也可以的 -->
    <script>
      const _instanceof2 = (obj, constructor) => {
        const rightPrototype = constructor.prototype;
        let leftPrototype = Object.getPrototypeOf(obj);

        while (true) {
          if (leftPrototype === null) return false;

          if (leftPrototype !== rightPrototype) {
            leftPrototype = Object.getPrototypeOf(leftPrototype);
          } else {
            return true;
          }
        }

        return false;
      };

      const arr2 = [1];
      const res2 = _instanceof(arr, Array);
      console.log("res2", res2);
    </script>
  </body>
</html>
