# HTTP

## (一) HTTP 方法

### (1.1) HTTP 有哪些请求方法

- HTTP1.0 定义了三种方法：GET，POST，HEAD
- HTTP1.1 定义了五种方法：PUT，PATCH，DELETE，OPTIONS，CONNECT

```
OPTIONS
- 用于获取目的资源所支持的 ( 请求方法 )
- 返回报文的 ( 报文首部 - 响应头 ) 中包含 ( Allow ) 字段，值是所支持的请求方法
- 响应头 Allow: GET,POST
- 应用: 比如 cors 设置跨域时，如果是非简单请求，就会先进行 options 请求


CONNECT
- 该方法可以开启一个客户端与所请求资源之间的双向沟通的通道。它可以用来创建隧道（tunnel）
- HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
```

### (1.2) GET 和 POST 的区别？

- 作用
  - GET 获取资源
  - POST 添加资源/更新资源
- 参数
  - GET 通过 query 传递参数
  - POST 通过 body 传递参数
  - `本质上 GET 和 POST 都能通过 query 和 body 传递数据`
- 幂等
  - GET 幂等
  - POST 非幂等
- 书签和缓存
  - GET 可以作为书签，能被浏览器和代理服务器缓存
  - POST 不能作为书签，不能被浏览器和代理服务器缓存
- TCP 数据包个数
  - GET 产生一个 TCP 数据包， POST 产生两个 TCP 数据包
  - GET: 浏览器会把 ( header 和 data ) 一并发送出去，服务器响应 200（返回数据）
  - POST: 浏览器( 先发送 header )，服务器响应 100 continue 表示继续请求，然后浏览器 ( 再发送 data )，服务器响应 200 ok（返回数据）

### (1.3) PUT 和 POST 的区别？

- 幂等性
  - PUT 是幂等的，即 连续调用一次或者多次的效果相同（无副作用）
  - POST 是非幂等的
- 资源
  - PUT 的 URI 指向是具体单一资源 -- 更新资源
  - POST 可以指向资源集合 --------- 新增资源
- 总结
  - POST 用于新增资源，非幂等，即多次提交会多次添加新资源
  - PUT 用于修改资源，幂等，每次提交都是修改成同样的内容，只争对单一资源

### (1.4) PUT 和 PATCH 的区别？

- 两者都可以 更新资源
- PATCH 是对资源进行局部更新，这样 PATCH 就会少提交一些 body 属性，减小报文大小
- patch 是补丁的意思，PATCH 是对 PUT 方法的补充

## (二) http1.0 和 http1.1 的区别？

- http1.0
  - 无状态
  - 无连接
- http1.0
  - 长连接
  - 管道化
  - 缓存
  - 断点续传

```HTTP1.0
HTTP1.0
---

(1) 无状态
1. 服务器不跟踪记录请求过的状态
2. 对于无状态的特性可以借助 ( cookie/session ) 机制来做 ( 身份认证 ) 和 ( 状态记录 )

(2) 无连接
无连接导致的性能缺陷主要有两种：
1. 无法复用链接: 每次发送请求，都需要进行tcp链接，即三次握手和四次挥手，使得网络的利用率极低
2. 对头阻塞: http1.0规定，在前一个请求响应到达之后，下一个请求才能发送，如何前一个请求阻塞，后面的就都会阻塞
```

```HTTP1.1
HTTP1.1
---

(1) 长连接
- HTTP1.1默认保持长连接，数据传输完成，保持tcp链接不断开，继续使用这个通道传输数据
- 响应头：Connection: Keep-Alive
- 响应头：Keep-Alive: timeout=5, max=1000
          - timeout：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）
          - max：在连接关闭之前，在此连接可以发送的请求的最大值

(2) 管道化
- http1.0
    - 请求1 > 响应1 --> 请求2 > 响应2 --> 请求3 > 响应3
- http1.1
    - 请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3
- 虽然管道化一次可以发送多个请求，但响应仍然是顺序返回，仍然无法解决对头阻塞的问题

(3) 缓存处理
- HTTP1.1新增 Cache-Control 字段
    - http1.0  =>  expires           => 是一个绝对时间点，用GMT时间格式
    - http1.1  =>  Cache-Control     => 是一个相时时间段，以秒为单位
- Cache-control: no-cache,private,max-age=123123
    - no-cache：不使用强缓存，使用协商缓存
    - max-age: 一个时间段，单位是秒
    - public：允许所有服务器缓存该资源
    - private：表示该资源仅仅属于发出请求的最终用户，这将禁止中间服务器（如代理服务器）缓存此类资源
               对于包含用户个人信息的文件，可以设置private
- Expires 和 Cache-Control 对比
    - 如果同时开启，Cache-Control 的优先级高于 Expires
    - expires是一个用GMT时间表示的时间点，Cache-Control是用秒表示的时间段(一个差值)，都是和浏览器本地时间做对比
    - Cache-Control 比 Expires 更加精确

(4) 断点续传
- 请求头：Range
- 响应头：Content-Range
- 原理
    - 在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载
    - 如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率
- 案例：
    - Range: bytes=0-801
    - Content-Range: bytes 0-800/801
```

## (三) http2.0

- 二进制分帧
- 多路复用：在共享 TCP 链接的基础上同时发送请求和响应
- 头部压缩
- 服务器推送：服务器可以额外的向客户端推送资源，而无需客户端明确的请求
```
HTTP2.0

(1) 二进制分帧
- 将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码

(2) 多路复用
- 基于二进制分帧
- 在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来
- 比如：一个页面有三个http请求，在HTTP1.0时需要发三次http请求，而HTTP2.0只需要发送一次HTTP请求，将之前的三次分层不同的stream，乱序发送

(3) 头部压缩
- 将http中的头部中的key:value的纯文本，在两端做了一个映射表，发送的时候只需要记录key就可以了
```